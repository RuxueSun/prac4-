#################### netup function
## purpose:
## Input:
##      d:a vector giving the number of nodes in each layer of a network.
## Output:
##      h: a list of nodes for each layer.
##      w: a list of weight matrices.
##      b: a list of offset vectors.

netup <- function(d){
  
  # calculate the number of layers
  layer <- length(d)
  
  # Initialize weight matrices with U(0, 0.2) random deviates
  W <- vector('list', layer-1)
  for (i in 1:(layer-1)){
    W[[i]] <- matrix(runif(d[i] * d[i+1],0 , 0.2), nrow = d[i+1], ncol = d[i])
  }
  
  # Initialize offset vectors with U(0, 0.2) random deviates
  b <- vector('list', layer-1)
  for (i in 1:(layer-1)){
    b[[i]] <- runif(d[i+1],0,0.2)
  }
  
  # Initialize nodes for each layer
  h <- vector('list', layer)
  
  # nodes for first layer is the values of input data
  h[[1]] <- numeric(d[1])
  
  # nodes for other layers
  for (i in 2:layer){
    for (j in 1:d[i]){
      h[[i]][j] <- max(0,W[[i-1]][j,] %*% h[[i-1]] + b[[i-1]][j])
    }
  }
  
  network <- list(h=h, W=W, b=b)
  
  return(network)
  
}

#################### forward function
## purpose:
## Input:
##       nn: a network list as returned by netup.
##       inp: a vector of input values for the first layer.
## Output:
##       updated network list.

forward <- function(nn,inp){
  
  # recall the results of netup function
  h <- nn$h
  W <- nn$W 
  b <- nn$b 
  
  # values for the first layer
  h[[1]] <- inp
  
  # nodes for other layers
  for (i in 2:length(W)+1){
    h[[i]] <- pmax(0, W[[i-1]] %*% h[[i-1]] + b[[i-1]])
  }
  
  network <- list(h=h, W=W, b=b)
  
  return(network)
}
